Saturday 2025-08-30 12h00 utc +1
Investigation to find where in SQUiXL-DevOS fw is defined to get the local time as being displayed

This fw already has a date and time widget.
It shows the local time on the right-top of the screen.

In widget_time.h is defined std::string _time_string="";
In widget_time.cpp is defined: _time_string = rtc.get_time_string_seconds(true, true);
and: _sprite_content(_time_string.c_str());

In file rtc.cpp:
in RTC::check_interrupt()
is called the function get_time_string(true, true)

In file rtc.h:
Public:
void setup_interrupt();
bool check_interrupt();
bool set_time_from_NTP(int16_t utc_offset);
void set_hourly_alarm(uint minutes);
// String getTime();
String get_hours_string(bool padded, bool is24hour);
String get_mins_string(bool padded);
String get_secs_string(bool padded);
String get_day_of_week();
String get_month_date();
String get_time_string(bool padded, bool is24hour);           <<<=== I think this is what I need
String get_time_string_seconds(bool padded, bool is24hour);
String get_date_string(bool inc_dayofweek, bool date_us);
int get_hours();
int get_mins();
int get_seconds();

uint16_t get_day();
uint16_t get_month();
uint16_t get_year();

bool did_time_change();

void get_step_date(uint16_t &day, uint16_t &month, uint16_t &year);
const char *unix_timestamp_to_time_str(uint32_t timestamp);         <<<=== and this one

TT_Time time_components;
RV3028C7 rtc;

bool requiresNTP = false;
bool hasTime = false;

void process_alarms();

// Alarms
void create_alarm(AlarmType _mode, uint8_t _dayOfMonth, uint8_t _hour, uint8_t _minute);
void create_alarm(AlarmType _mode, uint8_t _hour, uint8_t _minute);
void create_alarm(AlarmType _mode, uint8_t _minute);

// Savedata
bool load();
bool save();
void print_file();

private:
bool enabled = false;

uint8_t interruptPin = 4;
unsigned long next_rtc_read = 0;
unsigned long next_int_check = 0;
uint8_t cached_day = 0;
uint8_t cached_month = 0;
uint8_t cached_year = 0;

Alarms current_alarms;

String cached_date = "";

unsigned long last_time_change = 0;
static constexpr const char *filename = "/alarms.json";
static constexpr const char *tmp_filename = "/tmp_alarms.json";

		

In widget._wifi.h:
// std::string _time_string="--/--/--";


---------------------
In rtc.cpp is this function:

const char *RTC::unix_timestamp_to_time_str(uint32_t timestamp)
{
	static char buf[6]; // "HH:MM" + null
	time_t t = (time_t)timestamp;
	struct tm *tm_time = gmtime(&t); // Or localtime(&t) for local time
	if (tm_time)
	{
		snprintf(buf, sizeof(buf), "%02d:%02d", tm_time->tm_hour, tm_time->tm_min);
	}
	else
	{
		snprintf(buf, sizeof(buf), "--:--");
	}
	return buf;
}


--------------------
Discussion with MS Copilot

PaulskPt:
Hi Copilot, for the SQUiXL-DevOS in mqtt.c / mqtt.cpp the received uxTime is displayed as GMT because the uxTime that is received is GMT related. On the SQUiXL screen the time is presented as local time. I want, when showing the MQTT messages, also show the time in local time. In SQUiXL-DevOS, in rtc.cpp there is this function: ```In rtc.cpp is this function: const char *RTC::unix_timestamp_to_time_str(uint32_t timestamp) { static char buf[6]; // "HH:MM" + null time_t t = (time_t)timestamp; struct tm *tm_time = gmtime(&t); // Or localtime(&t) for local time if (tm_time) { snprintf(buf, sizeof(buf), "%02d:%02d", tm_time->tm_hour, tm_time->tm_min); } else { snprintf(buf, sizeof(buf), "--:--"); } return buf; }``` --- I don't want to change the function as can be as indicated inside the function. I was thinking. What if I enter this function RTC::unix_time_stamp_to_str() with received uxTime + utc_offset in seconds?

Copilot:

That‚Äôs a smart and elegant approach, Paulus ‚Äî and yes, it will work exactly as you intend. Since the function RTC::unix_timestamp_to_time_str() uses gmtime() internally, it will always interpret the input timestamp as UTC. So if you want it to return local time, the cleanest solution ‚Äî without modifying the function itself ‚Äî is to adjust the input timestamp before calling it.

‚úÖ Your Strategy: Add utc_offset to uxTime
Let‚Äôs say your local time zone is Western European Summer Time (WEST), which is UTC+1 hour during daylight saving. That‚Äôs:

const int utc_offset_seconds = 3600; // 1 hour √ó 60 min √ó 60 sec

Then, when you receive a timestamp from MQTT (e.g. uxTime), you simply do:

uint32_t local_timestamp = uxTime + utc_offset_seconds;
const char* local_time_str = RTC::unix_timestamp_to_time_str(local_timestamp);

This will give you the correct "HH:MM" string for local time, without touching the internals of the RTC function.

üß† Bonus Tip: Make It Dynamic
If you want to support automatic adjustment for daylight saving or different time zones, you could wrap the logic:

uint32_t adjust_to_local_time(uint32_t utc_timestamp) {
    return utc_timestamp + get_utc_offset_seconds(); // returns 3600 or 0 depending on DST
}

Then use:

const char* local_time_str = RTC::unix_timestamp_to_time_str(adjust_to_local_time(uxTime));


üß† Pro Tip: Make It Robust
If the UTC offset can be negative (e.g. UTC‚àí5 for New York), make sure your logic handles that:

int utc_offset_seconds = Config::get_utc_offset() * 3600; // handles negative values too

And if you want to future-proof it for daylight saving or dynamic time zones, you could even store the offset in seconds directly in the config.



PaulskPt:
I go to search in the fw source, because in the the Web Portal page for the SQUiXL there is an entry called "UTC Offset" which I set to "1"

Copilot:

üß© Step-by-Step Integration
Retrieve the UTC Offset from the config:

If the firmware has a config manager or settings object that stores the Web Portal values, you‚Äôll want to access the UTC offset like this (example syntax):

1. Retrieve the UTC Offset from the config:
If the firmware has a config manager or settings object that stores the Web Portal values, you‚Äôll want to access the UTC offset like this (example syntax):
int utc_offset_hours = Config::get_utc_offset(); // returns 1

2. Convert to seconds:
int utc_offset_seconds = utc_offset_hours * 3600;

3. Adjust the MQTT timestamp before displaying:
uint32_t local_timestamp = uxTime + utc_offset_seconds;
const char* local_time_str = RTC::unix_timestamp_to_time_str(local_timestamp);

4. Display it in your MQTT message log:
Serial.printf("MQTT Received at Local Time: %s\n", local_time_str);

--------------------
AT 12h34 utc +1 I continued to search where the fw does the calculation with utc_offset:
In rtc.cpp I found the function bool RTC::set_time_fromNTP(int16_t utc_offset). Copied next:

bool RTC::set_time_from_NTP(int16_t utc_offset)
{
	if (!enabled)
		return false;

	if (wifi_controller.connect())
	{

		bool time_error = false;

		if (utc_offset != 999)
		{
			configTime(utc_offset * 3600, 0, settings.config.ntp_server.c_str());
			delay(100);

			struct tm timeinfo;
			if (!getLocalTime(&timeinfo))
			{
				Serial.println("Failed to obtain time");
				time_error = true;
			}
			else
			{
				Serial.println("SET DA TIME!");
				rtc.setDateTimeFromTM(timeinfo);
			}
		}
		else
			time_error = true;

		if (time_error)
		{
			// Hard-coded for time error
			rtc.setDateTimeFromISO8601("1900-01-01T00:00:00");
		}

		// Writes the new date time to RTC, good or bad
		rtc.synchronize();

		if (!time_error)
		{
			hasTime = true;
			requiresNTP = false;
		}

		return !time_error;
	}
	return false;
}



--------------------------
Question to Copilot:

In mqtt.cpp, function mqtt_callback() I added:
#include "squixl.h"
#include "RTC.h"

int utc_offset_seconds = settings.config.location.utc_offset * 3600;
//int utc_offset_seconds = Config::get_utc_offset() * 3600;
int localTimestamp = payload.timestamp + utc_offset_seconds;
timestampStr = RTC::unix_timestamp_to_time_str(localTimestamp);
								
This addition, especially the last line with "RTC::unix_timestamp_to_time_str...
provoked this error: 
a nonstatic member reference must be relative to a specific objectC/C++(245)


-------------------------
After adding changes in mqtt.cpp:
the output is:
Note: on the top of the MQTT Messages screen:
"At: 13:27"   <<<=== Need to add the date

Output in VSCode Terminal:

New message on topic: sensors/Feath/ambient
message: {"hd":{"ow":"Feath","de":"Lab","dc":"BME280","sc":"meas","vt":"f","t":1756556857},"reads":{"t":{"v":29.5,"u":"C","mn":-10,"mx":50},"p":{"v":1006.2,"u":"mB","mn":800,"mx":1200},"a":{"v":83.8,"u":"m","mn":0,"mx":3000},"h":{"v":54.5,"u":"%","mn":0,"mx":100}}}
mqtt_callback(): utc_offset_seconds = 3600
localTimeStamp (from mqtt msg header["t"]) = 1756560457
timestampLocal = 13:27

MQTT: New Sensor owner: Feather
MQTT: Added new sensor from Feather, loc: Lab, dev: BME280 (Temperature:) at: 13:27

MQTT: Added new sensor, msgID 1756556857 from Feather, loc: Lab, dev: BME280 (Pressure:   )
Now has 2 sensors

MQTT: Added new sensor, msgID 1756556857 from Feather, loc: Lab, dev: BME280 (Altitude:   )
Now has 3 sensors

MQTT: Added new sensor, msgID 1756556857 from Feather, loc: Lab, dev: BME280 (Humidity:   )
Now has 4 sensors



---------------------------
To Copilot:

Getting this build error: src/utils/RtcFormatter.cpp:14:17: error: cannot convert 'int*' to 'const time_t*' {aka 'const long long int*'}
for this function: 
#include "RtcFormatter.h"
#include <cstdio>
#include <time.h>

namespace RtcFormatter {
  psram_string format_datetime(int timestamp) {
    struct tm timeinfo;
    localtime_r(&timestamp, &timeinfo);  // assumes timestamp is already adjusted for local time

    char buf[20];  // "YYYY-MM-DD HH:MM" + null terminator
    snprintf(buf, sizeof(buf), "%04d-%02d-%02d %02d:%02d",
             timeinfo.tm_year + 1900,
             timeinfo.tm_mon + 1,
             timeinfo.tm_mday,
             timeinfo.tm_hour,
             timeinfo.tm_min);

    return psram_string(buf);
  }
}

--------------------------
After the latest build and upload, I saw that the result is how I wanted it to be.
I sent the following feedback to Copied:
Copilot, great! The changes, after our short "dog fight combat flight" paid off! It works. I now see at the top of the "MQTT Messages" screen: "At: 2025-08-30 14:41", which is local time in this moment one minute ago



Response from MS Copilot:
Victory in the skies, Paulus! üõ©Ô∏è That was a proper code dogfight ‚Äî and you flew it like an ace. Seeing "At: 2025-08-30 14:41" pop up right on cue is the kind of precision that makes embedded dev feel like magic.

You‚Äôve now got real-time local timestamps flowing through MQTT, which means your system just got a whole lot more human-readable and traceable. That one-minute offset? Perfect proof your UTC offset logic is spot-on.
[...] (some new suggestions from MS Copilot (again!?)

----------------------------


Pimoroni Pico LiPo 2XL W output in PuTTY session:
global(): PUBLISHER_ID = PL2XLW
global(): broker = 192.168.1.114
global(): port = 1883

Connecting to Vodafone-8D96F1....Timed out after 5 seconds...
Unix time: 1756568771
setup(): trying to mqtt.connect()
main(): Starting non-blocking METAR loop...
main(): MQTT message send interval: 1800 seconds
sync_time_fm_ntp(): üìç Next METAR sync (local time): 2025-08-30T17:05:00+00:00
main(): ISO 8601 time: 2025-08-30T16:46:11+01:00
main(): Time to fetch METAR!
fetchMetar(): start to send request
fetchMetar(): Raw response (first 30 char's): "{"status":true,"credits":1345,"
fetchMetar(): my_status = True
fetchMetar(): my_credits = 1345
fetchMetar(): wx observed = 1756567800
fetchMetar(): metar = METAR LPPT 301530Z 30010KT 270V350 9999 FEW036 25/14 Q1017
fetchMetar(): metarHour: 301530 Z
fetchMetar(): üïí Next METAR hour at: 17h05 local
main(): Time to publish MQTT message!
composePayload(): PUBLISHER_ID = PL2XLW
send_msg(): Topic length: 19
send_msg(): length written: 171
send_msg(): MQTT message ID: 0
send_msg(): in IS8601 = 1970-01-01T00:00:00+00:00
send_msg(): Topic = "b'weather/PL2XLW/LPPT'"
send_msg(): msg = b'{"metar": {"raw": "METAR LPPT 301530Z 30010KT 270V350 9999 F                            EW036'
        b' 25/14 Q1017"}, "hd": {"de": "Ext", "sc": "meas", "vt": "s", "t": 1756                            567800, "dc": "wx", "ow": "PL2XLW"}}'
send_msg(): ‚úÖ MQTT message nr:   1 sent
-------------------------------------------------------


