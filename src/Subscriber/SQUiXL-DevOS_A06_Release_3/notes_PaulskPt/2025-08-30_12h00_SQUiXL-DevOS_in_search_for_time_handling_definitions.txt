Saturday 2025-08-30 12h00 utc +1
Investigation to find where in SQUiXL-DevOS fw is defined to get the local time as being displayed

This fw already has a date and time widget.
It shows the local time on the right-top of the screen.

In widget_time.h is defined std::string _time_string="";
In widget_time.cpp is defined: _time_string = rtc.get_time_string_seconds(true, true);
and: _sprite_content(_time_string.c_str());

In file rtc.cpp:
in RTC::check_interrupt()
is called the function get_time_string(true, true)

In file rtc.h:
Public:
void setup_interrupt();
bool check_interrupt();
bool set_time_from_NTP(int16_t utc_offset);
void set_hourly_alarm(uint minutes);
// String getTime();
String get_hours_string(bool padded, bool is24hour);
String get_mins_string(bool padded);
String get_secs_string(bool padded);
String get_day_of_week();
String get_month_date();
String get_time_string(bool padded, bool is24hour);           <<<=== I think this is what I need
String get_time_string_seconds(bool padded, bool is24hour);
String get_date_string(bool inc_dayofweek, bool date_us);
int get_hours();
int get_mins();
int get_seconds();

uint16_t get_day();
uint16_t get_month();
uint16_t get_year();

bool did_time_change();

void get_step_date(uint16_t &day, uint16_t &month, uint16_t &year);
const char *unix_timestamp_to_time_str(uint32_t timestamp);         <<<=== and this one

TT_Time time_components;
RV3028C7 rtc;

bool requiresNTP = false;
bool hasTime = false;

void process_alarms();

// Alarms
void create_alarm(AlarmType _mode, uint8_t _dayOfMonth, uint8_t _hour, uint8_t _minute);
void create_alarm(AlarmType _mode, uint8_t _hour, uint8_t _minute);
void create_alarm(AlarmType _mode, uint8_t _minute);

// Savedata
bool load();
bool save();
void print_file();

private:
bool enabled = false;

uint8_t interruptPin = 4;
unsigned long next_rtc_read = 0;
unsigned long next_int_check = 0;
uint8_t cached_day = 0;
uint8_t cached_month = 0;
uint8_t cached_year = 0;

Alarms current_alarms;

String cached_date = "";

unsigned long last_time_change = 0;
static constexpr const char *filename = "/alarms.json";
static constexpr const char *tmp_filename = "/tmp_alarms.json";

		

In widget._wifi.h:
// std::string _time_string="--/--/--";


---------------------
In rtc.cpp is this function:

const char *RTC::unix_timestamp_to_time_str(uint32_t timestamp)
{
	static char buf[6]; // "HH:MM" + null
	time_t t = (time_t)timestamp;
	struct tm *tm_time = gmtime(&t); // Or localtime(&t) for local time
	if (tm_time)
	{
		snprintf(buf, sizeof(buf), "%02d:%02d", tm_time->tm_hour, tm_time->tm_min);
	}
	else
	{
		snprintf(buf, sizeof(buf), "--:--");
	}
	return buf;
}


--------------------
Discussion with MS Copilot

PaulskPt:
Hi Copilot, for the SQUiXL-DevOS in mqtt.c / mqtt.cpp the received uxTime is displayed as GMT because the uxTime that is received is GMT related. On the SQUiXL screen the time is presented as local time. I want, when showing the MQTT messages, also show the time in local time. In SQUiXL-DevOS, in rtc.cpp there is this function: ```In rtc.cpp is this function: const char *RTC::unix_timestamp_to_time_str(uint32_t timestamp) { static char buf[6]; // "HH:MM" + null time_t t = (time_t)timestamp; struct tm *tm_time = gmtime(&t); // Or localtime(&t) for local time if (tm_time) { snprintf(buf, sizeof(buf), "%02d:%02d", tm_time->tm_hour, tm_time->tm_min); } else { snprintf(buf, sizeof(buf), "--:--"); } return buf; }``` --- I don't want to change the function as can be as indicated inside the function. I was thinking. What if I enter this function RTC::unix_time_stamp_to_str() with received uxTime + utc_offset in seconds?

Copilot:

That’s a smart and elegant approach, Paulus — and yes, it will work exactly as you intend. Since the function RTC::unix_timestamp_to_time_str() uses gmtime() internally, it will always interpret the input timestamp as UTC. So if you want it to return local time, the cleanest solution — without modifying the function itself — is to adjust the input timestamp before calling it.

✅ Your Strategy: Add utc_offset to uxTime
Let’s say your local time zone is Western European Summer Time (WEST), which is UTC+1 hour during daylight saving. That’s:

const int utc_offset_seconds = 3600; // 1 hour × 60 min × 60 sec

Then, when you receive a timestamp from MQTT (e.g. uxTime), you simply do:

uint32_t local_timestamp = uxTime + utc_offset_seconds;
const char* local_time_str = RTC::unix_timestamp_to_time_str(local_timestamp);

This will give you the correct "HH:MM" string for local time, without touching the internals of the RTC function.

🧠 Bonus Tip: Make It Dynamic
If you want to support automatic adjustment for daylight saving or different time zones, you could wrap the logic:

uint32_t adjust_to_local_time(uint32_t utc_timestamp) {
    return utc_timestamp + get_utc_offset_seconds(); // returns 3600 or 0 depending on DST
}

Then use:

const char* local_time_str = RTC::unix_timestamp_to_time_str(adjust_to_local_time(uxTime));


🧠 Pro Tip: Make It Robust
If the UTC offset can be negative (e.g. UTC−5 for New York), make sure your logic handles that:

int utc_offset_seconds = Config::get_utc_offset() * 3600; // handles negative values too

And if you want to future-proof it for daylight saving or dynamic time zones, you could even store the offset in seconds directly in the config.



PaulskPt:
I go to search in the fw source, because in the the Web Portal page for the SQUiXL there is an entry called "UTC Offset" which I set to "1"

Copilot:

🧩 Step-by-Step Integration
Retrieve the UTC Offset from the config:

If the firmware has a config manager or settings object that stores the Web Portal values, you’ll want to access the UTC offset like this (example syntax):

1. Retrieve the UTC Offset from the config:
If the firmware has a config manager or settings object that stores the Web Portal values, you’ll want to access the UTC offset like this (example syntax):
int utc_offset_hours = Config::get_utc_offset(); // returns 1

2. Convert to seconds:
int utc_offset_seconds = utc_offset_hours * 3600;

3. Adjust the MQTT timestamp before displaying:
uint32_t local_timestamp = uxTime + utc_offset_seconds;
const char* local_time_str = RTC::unix_timestamp_to_time_str(local_timestamp);

4. Display it in your MQTT message log:
Serial.printf("MQTT Received at Local Time: %s\n", local_time_str);

--------------------
AT 12h34 utc +1 I continued to search where the fw does the calculation with utc_offset:
In rtc.cpp I found the function bool RTC::set_time_fromNTP(int16_t utc_offset). Copied next:

bool RTC::set_time_from_NTP(int16_t utc_offset)
{
	if (!enabled)
		return false;

	if (wifi_controller.connect())
	{

		bool time_error = false;

		if (utc_offset != 999)
		{
			configTime(utc_offset * 3600, 0, settings.config.ntp_server.c_str());
			delay(100);

			struct tm timeinfo;
			if (!getLocalTime(&timeinfo))
			{
				Serial.println("Failed to obtain time");
				time_error = true;
			}
			else
			{
				Serial.println("SET DA TIME!");
				rtc.setDateTimeFromTM(timeinfo);
			}
		}
		else
			time_error = true;

		if (time_error)
		{
			// Hard-coded for time error
			rtc.setDateTimeFromISO8601("1900-01-01T00:00:00");
		}

		// Writes the new date time to RTC, good or bad
		rtc.synchronize();

		if (!time_error)
		{
			hasTime = true;
			requiresNTP = false;
		}

		return !time_error;
	}
	return false;
}



--------------------------
Question to Copilot:

In mqtt.cpp, function mqtt_callback() I added:
#include "squixl.h"
#include "RTC.h"

int utc_offset_seconds = settings.config.location.utc_offset * 3600;
//int utc_offset_seconds = Config::get_utc_offset() * 3600;
int localTimestamp = payload.timestamp + utc_offset_seconds;
timestampStr = RTC::unix_timestamp_to_time_str(localTimestamp);
								
This addition, especially the last line with "RTC::unix_timestamp_to_time_str...
provoked this error: 
a nonstatic member reference must be relative to a specific objectC/C++(245)


-------------------------
After adding changes in mqtt.cpp:
the output is:
Note: on the top of the MQTT Messages screen:
"At: 13:27"   <<<=== Need to add the date

Output in VSCode Terminal:

New message on topic: sensors/Feath/ambient
message: {"hd":{"ow":"Feath","de":"Lab","dc":"BME280","sc":"meas","vt":"f","t":1756556857},"reads":{"t":{"v":29.5,"u":"C","mn":-10,"mx":50},"p":{"v":1006.2,"u":"mB","mn":800,"mx":1200},"a":{"v":83.8,"u":"m","mn":0,"mx":3000},"h":{"v":54.5,"u":"%","mn":0,"mx":100}}}
mqtt_callback(): utc_offset_seconds = 3600
localTimeStamp (from mqtt msg header["t"]) = 1756560457
timestampLocal = 13:27

MQTT: New Sensor owner: Feather
MQTT: Added new sensor from Feather, loc: Lab, dev: BME280 (Temperature:) at: 13:27

MQTT: Added new sensor, msgID 1756556857 from Feather, loc: Lab, dev: BME280 (Pressure:   )
Now has 2 sensors

MQTT: Added new sensor, msgID 1756556857 from Feather, loc: Lab, dev: BME280 (Altitude:   )
Now has 3 sensors

MQTT: Added new sensor, msgID 1756556857 from Feather, loc: Lab, dev: BME280 (Humidity:   )
Now has 4 sensors



---------------------------
To Copilot:

Getting this build error: src/utils/RtcFormatter.cpp:14:17: error: cannot convert 'int*' to 'const time_t*' {aka 'const long long int*'}
for this function: 
#include "RtcFormatter.h"
#include <cstdio>
#include <time.h>

namespace RtcFormatter {
  psram_string format_datetime(int timestamp) {
    struct tm timeinfo;
    localtime_r(&timestamp, &timeinfo);  // assumes timestamp is already adjusted for local time

    char buf[20];  // "YYYY-MM-DD HH:MM" + null terminator
    snprintf(buf, sizeof(buf), "%04d-%02d-%02d %02d:%02d",
             timeinfo.tm_year + 1900,
             timeinfo.tm_mon + 1,
             timeinfo.tm_mday,
             timeinfo.tm_hour,
             timeinfo.tm_min);

    return psram_string(buf);
  }
}

--------------------------
After the latest build and upload, I saw that the result is how I wanted it to be.
I sent the following feedback to Copied:
Copilot, great! The changes, after our short "dog fight combat flight" paid off! It works. I now see at the top of the "MQTT Messages" screen: "At: 2025-08-30 14:41", which is local time in this moment one minute ago



Response from MS Copilot:
Victory in the skies, Paulus! 🛩️ That was a proper code dogfight — and you flew it like an ace. Seeing "At: 2025-08-30 14:41" pop up right on cue is the kind of precision that makes embedded dev feel like magic.

You’ve now got real-time local timestamps flowing through MQTT, which means your system just got a whole lot more human-readable and traceable. That one-minute offset? Perfect proof your UTC offset logic is spot-on.
[...] (some new suggestions from MS Copilot (again!?)

----------------------------


Pimoroni Pico LiPo 2XL W output in PuTTY session:
global(): PUBLISHER_ID = PL2XLW
global(): broker = 192.168.1.114
global(): port = 1883

Connecting to Vodafone-8D96F1....Timed out after 5 seconds...
Unix time: 1756568771
setup(): trying to mqtt.connect()
main(): Starting non-blocking METAR loop...
main(): MQTT message send interval: 1800 seconds
sync_time_fm_ntp(): 📍 Next METAR sync (local time): 2025-08-30T17:05:00+00:00
main(): ISO 8601 time: 2025-08-30T16:46:11+01:00
main(): Time to fetch METAR!
fetchMetar(): start to send request
fetchMetar(): Raw response (first 30 char's): "{"status":true,"credits":1345,"
fetchMetar(): my_status = True
fetchMetar(): my_credits = 1345
fetchMetar(): wx observed = 1756567800
fetchMetar(): metar = METAR LPPT 301530Z 30010KT 270V350 9999 FEW036 25/14 Q1017
fetchMetar(): metarHour: 301530 Z
fetchMetar(): 🕒 Next METAR hour at: 17h05 local
main(): Time to publish MQTT message!
composePayload(): PUBLISHER_ID = PL2XLW
send_msg(): Topic length: 19
send_msg(): length written: 171
send_msg(): MQTT message ID: 0
send_msg(): in IS8601 = 1970-01-01T00:00:00+00:00
send_msg(): Topic = "b'weather/PL2XLW/LPPT'"
send_msg(): msg = b'{"metar": {"raw": "METAR LPPT 301530Z 30010KT 270V350 9999 F                            EW036'
        b' 25/14 Q1017"}, "hd": {"de": "Ext", "sc": "meas", "vt": "s", "t": 1756                            567800, "dc": "wx", "ow": "PL2XLW"}}'
send_msg(): ✅ MQTT message nr:   1 sent
-------------------------------------------------------


